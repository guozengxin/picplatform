// This autogenerated skeleton file illustrates how to build a server.
// You should copy it to another filename to avoid overwriting it.

#include "gen-cpp/Blacklist.h"
#include "Configuration.hpp"
#include "ServerConfig.h"

#include <protocol/TBinaryProtocol.h>
#include <server/TSimpleServer.h>
#include <transport/TServerSocket.h>
#include <transport/TBufferTransports.h>
#include <Platform/docId/docId.h>
#include <stdio.h>
#include <map>
#include <string>
#include <fstream>


using namespace ::apache::thrift;
using namespace ::apache::thrift::protocol;
using namespace ::apache::thrift::transport;
using namespace ::apache::thrift::server;

using boost::shared_ptr;

using namespace  ::blacklist;

static uint64_t strToInteger(const char *str)
{           
	char *pEnd;
	uint64_t result = strtoull(str, &pEnd, 16);
	if (*pEnd != '\0') {
		return 0ull;
	}           
	return result;
}       

class BlacklistHandler : virtual public BlacklistIf {

	std::map<gDocID_t, int> docidMap;
	std::map<siteID_t, int> siteMap;
	std::map<domainID_t, int> domainMap;
	std::map<uint64_t, int> mfMap;
	std::map<uint64_t, int> picfilter1Map;

public:
	BlacklistHandler() {
		// Your initialization goes here
	}

	void loadBlacklist(const char *file) {
		std::ifstream fin(file);
		std::string line;
		char url[8192];
		int urltype;
		int urlPR;

		gDocID_t docid;
		siteID_t siteid;
		domainID_t domainid;
		int totalURL = 0;
		int totalSite = 0;
		int totalDomain = 0;
		int totalMF = 0;
		int totalPicFilter1 = 0;
		while (std::getline(fin, line)) {
			sscanf(line.c_str(), "%d\t%s\t%d", &urltype, url, &urlPR); 
			if (urltype == 0 || urltype == 1 || urltype == 2) {
				if (!url2DocId(url, &docid)) {
					continue; 
				}
			}
			if (urltype == 0) {
				docidMap.insert(std::make_pair(docid, 1));
				totalURL++;
			} else if (urltype == 1) {     
				siteid = docid.id.obs.site_id; 
				siteMap.insert(std::make_pair(siteid, 1));
				totalSite++;
			}
			else if(urltype == 2){
				domainid = docid.id.obs.domain_id;
				domainMap.insert(std::make_pair(domainid, 1));
				totalDomain++;
			} else if (urltype == 3) {     
				uint64_t t = strToInteger(url);
				if (t != 0ull && t != ULLONG_MAX) {
					totalMF ++;
					mfMap.insert(std::make_pair(t, 1));
				}
			} else if (urltype == 4) {     
				uint64_t t = strToInteger(url);
				if (t != 0ull && t != ULLONG_MAX) {
					totalPicFilter1 ++;            
					picfilter1Map.insert(std::make_pair(t, 1));
				}
			}
		}
		fprintf(stderr, "loadBlacklist [URL: %d] [site: %d] [domain: %d] [mf: %d] [picfilter1: %d]\n", totalURL, totalSite, totalDomain, totalMF, totalPicFilter1);
	}

	void filter(std::string& _return, const std::string& url, const std::string& mf, const std::string& picfilter1) {
		// Your implementation goes here
		fprintf(stderr, "[INPUT] url: %s mf: %s picfilter1: %s\n", url.c_str(), mf.c_str(), picfilter1.c_str());
		gDocID_t docid;
		siteID_t siteid;
		domainID_t domainid;
		if (!url2DocId(url.c_str(), &docid)) {
			_return.assign("ERROR");
			return; 
		}
		siteid = docid.id.obs.site_id; 
		domainid = docid.id.obs.domain_id;
		uint64_t mfValue = strToInteger(mf.c_str());
		uint64_t picfilter1Value = strToInteger(picfilter1.c_str());
		if (docidMap.find(docid) != docidMap.end()) {
			_return.append("url ");
		}
		if (siteMap.find(siteid) != siteMap.end()) {
			_return.append("site ");
		}
		if (domainMap.find(domainid) != domainMap.end()) {
			_return.append("domain ");
		}
		if (mfValue > 0 && mfMap.find(mfValue) != mfMap.end()) {
			_return.append("mf ");
		}
		if (picfilter1Value > 0 && picfilter1Map.find(picfilter1Value) != picfilter1Map.end()) {
			_return.append("picfilter1 ");
		}
		fprintf(stderr, "[FilterResult] %s\n", _return.c_str());
	}

	void getdocid(std::string& _return, const std::string& url) {
		// Your implementation goes here
		gDocID_t docid;
		if (!url2DocId(url.c_str(), &docid)) {
			return; 
		}
		_return.assign(docid.c_str().str);
	}

};


int loadConfiguration(const char* filename, shared_ptr<ServerConfig> cfg) {
	ConfigurationFile cf(filename);
	ConfigurationSection section;
	std::string s = "Server";
	std::string key;
	if (cf.GetSection(s.c_str(), section)) {
		key = "Port";
		cfg->port = section.Value<int>("Port", 0);
		if (cfg->port == 0) {
			fprintf(stderr, "%s config is not found in section %s\n", key.c_str(), s.c_str());
			return 1;
		}
		cfg->blFile = section.Value<std::string>("BlacklistPath", "");
	}
	return 0;
}

int main(int argc, char **argv) {
	if (argc < 2) {
		fprintf(stderr, "need configuration file\n");
		exit(1);
	}
	shared_ptr<ServerConfig> cfg(new ServerConfig);
	if (loadConfiguration(argv[1], cfg) != 0) {
		fprintf(stderr, "load configuration error\n");
		exit(1);
	}
	shared_ptr<BlacklistHandler> handler(new BlacklistHandler());
	handler->loadBlacklist(cfg->blFile.c_str());
	shared_ptr<TProcessor> processor(new BlacklistProcessor(handler));
	shared_ptr<TServerTransport> serverTransport(new TServerSocket(cfg->port));
	shared_ptr<TTransportFactory> transportFactory(new TBufferedTransportFactory());
	shared_ptr<TProtocolFactory> protocolFactory(new TBinaryProtocolFactory());

	TSimpleServer server(processor, serverTransport, transportFactory, protocolFactory);
	server.serve();
	return 0;
}

